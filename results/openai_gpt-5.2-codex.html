<!DOCTYPE html>
<html lang="ru">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Тетрис</title>
<style>
  :root{
    --bg:#0f1221;
    --panel:#171a2b;
    --accent:#5eead4;
    --text:#e5e7eb;
    --muted:#94a3b8;
  }
  *{box-sizing:border-box;margin:0;padding:0}
  body{
    font-family:system-ui,Segoe UI,Roboto,Arial,sans-serif;
    background:radial-gradient(1200px 800px at 20% 10%, #1b2240, #0b0e1c 70%);
    color:var(--text);
    display:flex;
    align-items:center;
    justify-content:center;
    min-height:100vh;
    padding:20px;
  }
  .app{
    display:grid;
    grid-template-columns:auto 240px;
    gap:20px;
    background:linear-gradient(180deg,#111526,#0d1020);
    padding:20px;
    border-radius:20px;
    box-shadow:0 20px 50px rgba(0,0,0,.4);
    width:min(900px,100%);
  }
  .game{
    position:relative;
    display:flex;
    align-items:center;
    justify-content:center;
    background:var(--panel);
    border-radius:16px;
    padding:12px;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.05);
  }
  canvas{
    width: min(70vw, 420px);
    aspect-ratio: 10/20;
    height:auto;
    background:#0a0d18;
    border-radius:10px;
  }
  .side{
    display:flex;
    flex-direction:column;
    gap:16px;
  }
  .card{
    background:var(--panel);
    padding:16px;
    border-radius:14px;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.05);
  }
  .title{
    font-size:20px;
    font-weight:700;
    margin-bottom:8px;
  }
  .stat{
    display:flex;
    justify-content:space-between;
    margin:6px 0;
    color:var(--muted);
  }
  .stat b{color:var(--text)}
  .next{
    display:flex;
    align-items:center;
    justify-content:center;
  }
  #next{
    width:140px;
    aspect-ratio: 4/4;
    background:#0a0d18;
    border-radius:10px;
  }
  .controls{
    display:grid;
    grid-template-columns:repeat(3,1fr);
    gap:8px;
  }
  .btn{
    border:none;
    background:#1f2a44;
    color:var(--text);
    padding:12px 10px;
    border-radius:10px;
    font-weight:600;
    cursor:pointer;
    transition:.2s;
  }
  .btn:hover{transform:translateY(-1px);background:#273252}
  .btn:active{transform:translateY(0)}
  .wide{grid-column:span 3}
  .small{
    font-size:12px;
    color:var(--muted);
    line-height:1.4;
  }
  @media (max-width:800px){
    .app{grid-template-columns:1fr}
    .side{order:-1}
    canvas{width:min(90vw,360px)}
  }
</style>
</head>
<body>
<div class="app">
  <div class="game">
    <canvas id="tetris" width="300" height="600"></canvas>
  </div>
  <div class="side">
    <div class="card">
      <div class="title">Тетрис</div>
      <div class="stat"><span>Очки</span><b id="score">0</b></div>
      <div class="stat"><span>Уровень</span><b id="level">1</b></div>
      <div class="stat"><span>Линии</span><b id="lines">0</b></div>
    </div>
    <div class="card">
      <div class="title">Следующая</div>
      <div class="next"><canvas id="next" width="120" height="120"></canvas></div>
    </div>
    <div class="card">
      <div class="title">Управление</div>
      <div class="controls">
        <button class="btn" id="left">◀</button>
        <button class="btn" id="rotate">⟳</button>
        <button class="btn" id="right">▶</button>
        <button class="btn wide" id="down">▼</button>
        <button class="btn wide" id="drop">Быстрый сброс</button>
        <button class="btn wide" id="pause">Пауза</button>
      </div>
      <div class="small" style="margin-top:10px">
        Клавиши: ← → ↓, пробел — сброс, ↑ — поворот, P — пауза.
      </div>
    </div>
  </div>
</div>

<script>
const canvas = document.getElementById('tetris');
const ctx = canvas.getContext('2d');
const nextCanvas = document.getElementById('next');
const nctx = nextCanvas.getContext('2d');

const scoreEl = document.getElementById('score');
const levelEl = document.getElementById('level');
const linesEl = document.getElementById('lines');

const COLS = 10, ROWS = 20, BLOCK = 30;
const COLORS = [
  null,
  '#22d3ee', // I
  '#a855f7', // T
  '#f97316', // L
  '#3b82f6', // J
  '#facc15', // O
  '#4ade80', // S
  '#ef4444'  // Z
];

const SHAPES = {
  I: [[1,1,1,1]],
  T: [[0,1,0],[1,1,1]],
  L: [[0,0,1],[1,1,1]],
  J: [[1,0,0],[1,1,1]],
  O: [[1,1],[1,1]],
  S: [[0,1,1],[1,1,0]],
  Z: [[1,1,0],[0,1,1]]
};
const SHAPE_KEYS = ['I','T','L','J','O','S','Z'];

let board = createMatrix(COLS, ROWS);
let dropCounter = 0;
let dropInterval = 800;
let lastTime = 0;
let paused = false;

let player = {
  pos:{x:0,y:0},
  matrix:null,
  next:null,
  score:0,
  lines:0,
  level:1
};

function createMatrix(w,h){
  const m=[];
  while(h--) m.push(new Array(w).fill(0));
  return m;
}

function createPiece(type){
  const shape = SHAPES[type];
  const index = SHAPE_KEYS.indexOf(type)+1;
  return shape.map(row=>row.map(v=>v?index:0));
}

function drawMatrix(matrix, offset, context=ctx, block=BLOCK){
  matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value){
        context.fillStyle = COLORS[value];
        context.fillRect((x+offset.x)*block, (y+offset.y)*block, block, block);
        context.strokeStyle = 'rgba(255,255,255,0.08)';
        context.strokeRect((x+offset.x)*block, (y+offset.y)*block, block, block);
      }
    });
  });
}

function collide(board, player){
  const m = player.matrix;
  const o = player.pos;
  for(let y=0;y<m.length;y++){
    for(let x=0;x<m[y].length;x++){
      if(m[y][x] !== 0 &&
        (board[y+o.y] && board[y+o.y][x+o.x]) !== 0){
        return true;
      }
    }
  }
  return false;
}

function merge(board, player){
  player.matrix.forEach((row,y)=>{
    row.forEach((value,x)=>{
      if(value) board[y+player.pos.y][x+player.pos.x] = value;
    });
  });
}

function rotate(matrix, dir){
  for(let y=0;y<matrix.length;y++){
    for(let x=0;x<y;x++){
      [matrix[x][y], matrix[y][x]] = [matrix[y][x], matrix[x][y]];
    }
  }
  if(dir>0) matrix.forEach(row=>row.reverse());
  else matrix.reverse();
}

function playerReset(){
  if(!player.next){
    player.next = createPiece(SHAPE_KEYS[Math.random()*SHAPE_KEYS.length|0]);
  }
  player.matrix = player.next;
  player.next = createPiece(SHAPE_KEYS[Math.random()*SHAPE_KEYS.length|0]);
  player.pos.y = 0;
  player.pos.x = (COLS/2|0) - (player.matrix[0].length/2|0);
  if(collide(board, player)){
    board = createMatrix(COLS, ROWS);
    player.score = 0;
    player.lines = 0;
    player.level = 1;
    dropInterval = 800;
    updateScore();
  }
  drawNext();
}

function drawNext(){
  nctx.clearRect(0,0,nextCanvas.width,nextCanvas.height);
  const m = player.next;
  const block = 24;
  const offset = {x: (4-m[0].length)/2, y: (4-m.length)/2};
  drawMatrix(m, offset, nctx, block);
}

function playerDrop(){
  player.pos.y++;
  if(collide(board, player)){
    player.pos.y--;
    merge(board, player);
    sweep();
    playerReset();
  }
  dropCounter = 0;
}

function playerMove(dir){
  player.pos.x += dir;
  if(collide(board, player)) player.pos.x -= dir;
}

function playerRotate(dir){
  const pos = player.pos.x;
  let offset = 1;
  rotate(player.matrix, dir);
  while(collide(board, player)){
    player.pos.x += offset;
    offset = -(offset + (offset>0?1:-1));
    if(offset > player.matrix[0].length){
      rotate(player.matrix, -dir);
      player.pos.x = pos;
      return;
    }
  }
}

function sweep(){
  let rowCount = 1;
  outer: for(let y=board.length-1;y>=0;y--){
    for(let x=0;x<board[y].length;x++){
      if(board[y][x] === 0) continue outer;
    }
    const row = board.splice(y,1)[0].fill(0);
    board.unshift(row);
    y++;
    player.score += rowCount * 100;
    player.lines += 1;
    rowCount *= 2;
  }
  if(player.lines >= player.level*10){
    player.level++;
    dropInterval = Math.max(120, dropInterval - 80);
  }
  updateScore();
}

function updateScore(){
  scoreEl.textContent = player.score;
  levelEl.textContent = player.level;
  linesEl.textContent = player.lines;
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  ctx.fillStyle = '#0a0d18';
  ctx.fillRect(0,0,canvas.width,canvas.height);
  drawMatrix(board, {x:0,y:0});
  drawMatrix(player.matrix, player.pos);
}

function update(time=0){
  const delta = time - lastTime;
  lastTime = time;
  if(!paused){
    dropCounter += delta;
    if(dropCounter > dropInterval) playerDrop();
    draw();
  }
  requestAnimationFrame(update);
}

document.addEventListener('keydown', e=>{
  if(e.key === 'ArrowLeft') playerMove(-1);
  else if(e.key === 'ArrowRight') playerMove(1);
  else if(e.key === 'ArrowDown') playerDrop();
  else if(e.key === 'ArrowUp') playerRotate(1);
  else if(e.key === ' ') { while(!collide(board, player)){ player.pos.y++; } player.pos.y--; merge(board, player); sweep(); playerReset(); }
  else if(e.key.toLowerCase() === 'p') togglePause();
});

function togglePause(){
  paused = !paused;
  document.getElementById('pause').textContent = paused ? 'Продолжить' : 'Пауза';
}

document.getElementById('left').onclick = ()=>playerMove(-1);
document.getElementById('right').onclick = ()=>playerMove(1);
document.getElementById('down').onclick = ()=>playerDrop();
document.getElementById('rotate').onclick = ()=>playerRotate(1);
document.getElementById('drop').onclick = ()=>{
  while(!collide(board, player)){ player.pos.y++; }
  player.pos.y--;
  merge(board, player); sweep(); playerReset();
};
document.getElementById('pause').onclick = togglePause;

function resizeCanvas(){
  const w = canvas.clientWidth;
  canvas.height = w*2;
  canvas.width = w;
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

playerReset();
update();
</script>
</body>
</html>