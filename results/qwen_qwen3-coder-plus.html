<!DOCTYPE html>
<html lang="ru">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Тетрис</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      background: linear-gradient(135deg, #1a2a6c, #b21f1f, #1a2a6c);
      font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
      color: white;
      overflow: hidden;
    }

    .game-container {
      display: flex;
      gap: 20px;
      padding: 20px;
      background: rgba(40, 40, 47, 0.8);
      border-radius: 16px;
      box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    }

    .board {
      width: 300px;
      height: 600px;
      background-color: #0d1b2a;
      border: 2px solid #415a77;
      display: grid;
      grid-template-rows: repeat(20, 1fr);
      grid-template-columns: repeat(10, 1fr);
      gap: 1px;
      padding: 2px;
    }

    .cell {
      background-color: #1b263b;
      border-radius: 2px;
    }

    .side-panel {
      display: flex;
      flex-direction: column;
      gap: 20px;
      width: 150px;
    }

    .next-piece-container {
      width: 120px;
      height: 120px;
      background: rgba(27, 39, 59, 0.7);
      border: 2px solid #415a77;
      border-radius: 8px;
      display: grid;
      grid-template-rows: repeat(4, 1fr);
      grid-template-columns: repeat(4, 1fr);
      gap: 2px;
      padding: 4px;
    }

    .stats {
      background: rgba(27, 39, 59, 0.7);
      border: 2px solid #415a77;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }

    .controls {
      background: rgba(27, 39, 59, 0.7);
      border: 2px solid #415a77;
      border-radius: 8px;
      padding: 15px;
      text-align: center;
    }

    h2 {
      margin-bottom: 10px;
      font-size: 1.2rem;
      color: #e0e1dd;
    }

    .stat-value {
      font-size: 1.5rem;
      font-weight: bold;
      color: #ff9e00;
    }

    button {
      background: #ff9e00;
      color: #0d1b2a;
      border: none;
      padding: 10px;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      margin-top: 10px;
      width: 100%;
    }

    button:hover {
      background: #ffaa33;
    }

    .filled {
      border-radius: 3px;
    }

    /* Цвета фигур */
    .i { background: #00f0f0; }
    .j { background: #0000f0; }
    .l { background: #f0a000; }
    .o { background: #f0f000; }
    .s { background: #00f000; }
    .t { background: #a000f0; }
    .z { background: #f00000; }

    @media (max-width: 600px) {
      .game-container {
        flex-direction: column;
        padding: 10px;
      }
      
      .side-panel {
        width: 300px;
        flex-direction: row;
        flex-wrap: wrap;
        justify-content: space-between;
      }
      
      .next-piece-container {
        order: 1;
        width: 120px;
      }
      
      .stats {
        order: 2;
        width: calc(50% - 10px);
      }
      
      .controls {
        order: 3;
        width: calc(50% - 10px);
      }
    }
  </style>
</head>
<body>
  <div class="game-container">
    <div class="board" id="board"></div>
    <div class="side-panel">
      <div class="next-piece-container" id="next-piece"></div>
      <div class="stats">
        <h2>Очки</h2>
        <div class="stat-value" id="score">0</div>
        <h2>Уровень</h2>
        <div class="stat-value" id="level">1</div>
        <h2>Линии</h2>
        <div class="stat-value" id="lines">0</div>
      </div>
      <div class="controls">
        <button id="start-btn">Старт</button>
        <button id="pause-btn">Пауза</button>
      </div>
    </div>
  </div>

  <script>
    document.addEventListener('DOMContentLoaded', () => {
      // Константы
      const COLS = 10;
      const ROWS = 20;
      const BLOCK_SIZE = 30;
      const EMPTY = 'empty';

      // Фигуры
      const SHAPES = [
        { name: 'i', matrix: [[0,0,0,0], [1,1,1,1], [0,0,0,0], [0,0,0,0]], color: 'i' },
        { name: 'j', matrix: [[1,0,0], [1,1,1], [0,0,0]], color: 'j' },
        { name: 'l', matrix: [[0,0,1], [1,1,1], [0,0,0]], color: 'l' },
        { name: 'o', matrix: [[1,1], [1,1]], color: 'o' },
        { name: 's', matrix: [[0,1,1], [1,1,0], [0,0,0]], color: 's' },
        { name: 't', matrix: [[0,1,0], [1,1,1], [0,0,0]], color: 't' },
        { name: 'z', matrix: [[1,1,0], [0,1,1], [0,0,0]], color: 'z' }
      ];

      // Элементы DOM
      const boardElement = document.getElementById('board');
      const nextPieceElement = document.getElementById('next-piece');
      const scoreElement = document.getElementById('score');
      const levelElement = document.getElementById('level');
      const linesElement = document.getElementById('lines');
      const startButton = document.getElementById('start-btn');
      const pauseButton = document.getElementById('pause-btn');

      // Игровое поле
      let board = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
      let score = 0;
      let level = 1;
      let lines = 0;
      let gameOver = false;
      let isPaused = false;
      let dropInterval = null;
      let gameSpeed = 500;

      // Текущая фигура
      let currentPiece = null;
      let nextPiece = null;

      // Создание игрового поля
      function createBoard() {
        boardElement.innerHTML = '';
        for (let r = 0; r < ROWS; r++) {
          for (let c = 0; c < COLS; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            cell.id = `cell-${r}-${c}`;
            boardElement.appendChild(cell);
          }
        }
      }

      // Создание следующей фигуры
      function createNextPieceBoard() {
        nextPieceElement.innerHTML = '';
        for (let r = 0; r < 4; r++) {
          for (let c = 0; c < 4; c++) {
            const cell = document.createElement('div');
            cell.className = 'cell';
            nextPieceElement.appendChild(cell);
          }
        }
      }

      // Получение случайной фигуры
      function getRandomPiece() {
        const piece = JSON.parse(JSON.stringify(SHAPES[Math.floor(Math.random() * SHAPES.length)]));
        return piece;
      }

      // Отрисовка фигуры
      function drawPiece(piece, boardRef = board, offsetRow = 0, offsetCol = 0, targetElement = boardElement) {
        for (let r = 0; r < piece.matrix.length; r++) {
          for (let c = 0; c < piece.matrix[r].length; c++) {
            if (piece.matrix[r][c]) {
              const boardRow = r + offsetRow;
              const boardCol = c + offsetCol;
              
              if (boardRow >= 0 && boardRow < ROWS && boardCol >= 0 && boardCol < COLS) {
                const cellId = `cell-${boardRow}-${boardCol}`;
                const cell = document.getElementById(cellId);
                if (cell) {
                  cell.className = `cell filled ${piece.color}`;
                }
              }
            }
          }
        }
      }

      // Очистка фигуры с поля
      function clearPiece(piece, row, col) {
        for (let r = 0; r < piece.matrix.length; r++) {
          for (let c = 0; c < piece.matrix[r].length; c++) {
            if (piece.matrix[r][c]) {
              const boardRow = r + row;
              const boardCol = c + col;
              
              if (boardRow >= 0 && boardRow < ROWS && boardCol >= 0 && boardCol < COLS) {
                const cellId = `cell-${boardRow}-${boardCol}`;
                const cell = document.getElementById(cellId);
                if (cell) {
                  cell.className = 'cell';
                }
              }
            }
          }
        }
      }

      // Проверка валидности позиции
      function isValidPosition(piece, row, col) {
        for (let r = 0; r < piece.matrix.length; r++) {
          for (let c = 0; c < piece.matrix[r].length; c++) {
            if (piece.matrix[r][c]) {
              const newRow = r + row;
              const newCol = c + col;
              
              if (
                newRow < 0 || 
                newRow >= ROWS || 
                newCol < 0 || 
                newCol >= COLS || 
                (newRow < ROWS && newCol < COLS && board[newRow][newCol] !== EMPTY)
              ) {
                return false;
              }
            }
          }
        }
        return true;
      }

      // Закрепление фигуры на поле
      function lockPiece() {
        for (let r = 0; r < currentPiece.matrix.length; r++) {
          for (let c = 0; c < currentPiece.matrix[r].length; c++) {
            if (currentPiece.matrix[r][c]) {
              const row = r + currentPiece.row;
              const col = c + currentPiece.col;
              
              if (row >= 0) {
                board[row][col] = currentPiece.color;
              }
            }
          }
        }
        
        // Проверка заполненных линий
        checkLines();
        
        // Создание новой фигуры
        spawnPiece();
        
        // Проверка окончания игры
        if (!isValidPosition(currentPiece, currentPiece.row, currentPiece.col)) {
          gameOver = true;
          clearInterval(dropInterval);
          alert(`Игра окончена! Ваш счёт: ${score}`);
        }
      }

      // Проверка и удаление заполненных линий
      function checkLines() {
        let linesCleared = 0;
        
        for (let r = ROWS - 1; r >= 0; r--) {
          if (board[r].every(cell => cell !== EMPTY)) {
            // Удаление строки
            for (let y = r; y > 0; y--) {
              board[y] = [...board[y - 1]];
            }
            board[0] = Array(COLS).fill(EMPTY);
            linesCleared++;
            r++; // Проверяем снова ту же строку
          }
        }
        
        if (linesCleared > 0) {
          // Начисление очков
          const points = [40, 100, 300, 1200]; // за 1, 2, 3, 4 линии
          score += points[linesCleared - 1] * level;
          lines += linesCleared;
          
          // Увеличение уровня каждые 10 линий
          const newLevel = Math.floor(lines / 10) + 1;
          if (newLevel > level) {
            level = newLevel;
            gameSpeed = Math.max(100, 500 - (level - 1) * 50);
            clearInterval(dropInterval);
            dropInterval = setInterval(moveDown, gameSpeed);
          }
          
          updateStats();
        }
      }

      // Обновление статистики
      function updateStats() {
        scoreElement.textContent = score;
        levelElement.textContent = level;
        linesElement.textContent = lines;
      }

      // Создание новой фигуры
      function spawnPiece() {
        currentPiece = nextPiece || getRandomPiece();
        nextPiece = getRandomPiece();
        
        currentPiece.row = 0;
        currentPiece.col = Math.floor((COLS - currentPiece.matrix[0].length) / 2);
        
        drawNextPiece();
      }

      // Отрисовка следующей фигуры
      function drawNextPiece() {
        // Очистка предыдущей
        const cells = nextPieceElement.querySelectorAll('.cell');
        cells.forEach(cell => {
          cell.className = 'cell';
        });
        
        // Рисуем новую
        if (nextPiece) {
          for (let r = 0; r < nextPiece.matrix.length; r++) {
            for (let c = 0; c < nextPiece.matrix[r].length; c++) {
              if (nextPiece.matrix[r][c]) {
                const index = r * 4 + c;
                if (cells[index]) {
                  cells[index].className = `cell filled ${nextPiece.color}`;
                }
              }
            }
          }
        }
      }

      // Движение фигуры вниз
      function moveDown() {
        if (isPaused || gameOver) return;
        
        if (isValidPosition(currentPiece, currentPiece.row + 1, currentPiece.col)) {
          clearPiece(currentPiece, currentPiece.row, currentPiece.col);
          currentPiece.row++;
          drawPiece(currentPiece, board, currentPiece.row, currentPiece.col);
        } else {
          lockPiece();
        }
      }

      // Перемещение фигуры влево
      function moveLeft() {
        if (isPaused || gameOver) return;
        
        if (isValidPosition(currentPiece, currentPiece.row, currentPiece.col - 1)) {
          clearPiece(currentPiece, currentPiece.row, currentPiece.col);
          currentPiece.col--;
          drawPiece(currentPiece, board, currentPiece.row, currentPiece.col);
        }
      }

      // Перемещение фигуры вправо
      function moveRight() {
        if (isPaused || gameOver) return;
        
        if (isValidPosition(currentPiece, currentPiece.row, currentPiece.col + 1)) {
          clearPiece(currentPiece, currentPiece.row, currentPiece.col);
          currentPiece.col++;
          drawPiece(currentPiece, board, currentPiece.row, currentPiece.col);
        }
      }

      // Поворот фигуры
      function rotate() {
        if (isPaused || gameOver) return;
        
        const originalMatrix = currentPiece.matrix;
        // Создаем транспонированную матрицу
        const rows = originalMatrix.length;
        const cols = originalMatrix[0].length;
        const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
        
        for (let r = 0; r < rows; r++) {
          for (let c = 0; c < cols; c++) {
            rotated[c][rows - 1 - r] = originalMatrix[r][c];
          }
        }
        
        const originalPos = { ...currentPiece };
        currentPiece.matrix = rotated;
        
        // Если позиция недопустима, возвращаем исходное состояние
        if (!isValidPosition(currentPiece, currentPiece.row, currentPiece.col)) {
          currentPiece.matrix = originalMatrix;
        } else {
          clearPiece(originalPos, originalPos.row, originalPos.col);
          drawPiece(currentPiece, board, currentPiece.row, currentPiece.col);
        }
      }

      // Быстрое падение
      function hardDrop() {
        if (isPaused || gameOver) return;
        
        while (isValidPosition(currentPiece, currentPiece.row + 1, currentPiece.col)) {
          currentPiece.row++;
        }
        lockPiece();
      }

      // Запуск игры
      function startGame() {
        if (dropInterval) {
          clearInterval(dropInterval);
        }
        
        // Сброс параметров
        board = Array(ROWS).fill().map(() => Array(COLS).fill(EMPTY));
        score = 0;
        level = 1;
        lines = 0;
        gameOver = false;
        isPaused = false;
        gameSpeed = 500;
        
        updateStats();
        createBoard();
        nextPiece = getRandomPiece();
        spawnPiece();
        drawPiece(currentPiece, board, currentPiece.row, currentPiece.col);
        
        dropInterval = setInterval(moveDown, gameSpeed);
      }

      // Пауза
      function togglePause() {
        isPaused = !isPaused;
        pauseButton.textContent = isPaused ? 'Продолжить' : 'Пауза';
      }

      // Обработчики событий
      document.addEventListener('keydown', e => {
        if (e.key === 'ArrowLeft') moveLeft();
        else if (e.key === 'ArrowRight') moveRight();
        else if (e.key === 'ArrowDown') moveDown();
        else if (e.key === 'ArrowUp') rotate();
        else if (e.key === ' ') hardDrop();
      });

      startButton.addEventListener('click', startGame);
      pauseButton.addEventListener('click', togglePause);

      // Инициализация
      createBoard();
      createNextPieceBoard();
      updateStats();
    });
  </script>
</body>
</html>