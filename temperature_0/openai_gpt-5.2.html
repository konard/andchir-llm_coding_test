<!doctype html>
<html lang="ru">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Tetris</title>
  <style>
    :root{
      --bg0:#0b0f17;
      --bg1:#101826;
      --card:rgba(255,255,255,.06);
      --card2:rgba(255,255,255,.10);
      --stroke:rgba(255,255,255,.12);
      --text:rgba(255,255,255,.92);
      --muted:rgba(255,255,255,.65);
      --accent:#7c5cff;
      --good:#23d18b;
      --warn:#ffcc66;
      --bad:#ff5c7a;
      --shadow: 0 18px 50px rgba(0,0,0,.55);
      --radius:18px;
    }

    *{box-sizing:border-box}
    html,body{height:100%}
    body{
      margin:0;
      font-family: ui-sans-serif, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji","Segoe UI Emoji";
      color:var(--text);
      background:
        radial-gradient(1200px 700px at 20% 10%, rgba(124,92,255,.35), transparent 55%),
        radial-gradient(900px 600px at 80% 20%, rgba(35,209,139,.20), transparent 60%),
        radial-gradient(800px 500px at 60% 95%, rgba(255,92,122,.18), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1));
      display:flex;
      align-items:center;
      justify-content:center;
      padding:16px;
    }

    .app{
      width:min(1040px, 100%);
      display:grid;
      gap:14px;
      grid-template-columns: 1.2fr .8fr;
      align-items:stretch;
    }

    @media (max-width: 900px){
      .app{grid-template-columns: 1fr; max-width: 520px;}
    }

    .panel{
      background: linear-gradient(180deg, rgba(255,255,255,.06), rgba(255,255,255,.04));
      border:1px solid var(--stroke);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      overflow:hidden;
      position:relative;
    }

    .panel::before{
      content:"";
      position:absolute;
      inset:-2px;
      background: radial-gradient(600px 200px at 20% 0%, rgba(255,255,255,.10), transparent 60%);
      pointer-events:none;
      opacity:.65;
    }

    .boardWrap{
      display:flex;
      gap:14px;
      padding:14px;
      align-items:stretch;
      justify-content:center;
    }

    .canvasCard{
      background: rgba(0,0,0,.25);
      border:1px solid var(--stroke);
      border-radius: 16px;
      padding:12px;
      position:relative;
      flex: 1;
      min-width: 260px;
      display:flex;
      align-items:center;
      justify-content:center;
    }

    canvas{
      width:100%;
      height:auto;
      max-height: 76vh;
      image-rendering: pixelated;
      border-radius: 12px;
      display:block;
      background:
        radial-gradient(1400px 800px at 30% 10%, rgba(124,92,255,.08), transparent 55%),
        linear-gradient(180deg, rgba(255,255,255,.03), rgba(0,0,0,.05));
      border:1px solid rgba(255,255,255,.10);
    }

    .side{
      width: 270px;
      min-width: 240px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    @media (max-width: 900px){
      .boardWrap{flex-direction:column; align-items:stretch;}
      .side{width:100%;}
      .canvasCard{min-width: unset;}
    }

    .hdr{
      padding:14px 16px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
      border-bottom:1px solid var(--stroke);
      background: rgba(255,255,255,.03);
    }

    .brand{
      display:flex; align-items:center; gap:10px;
      font-weight:700; letter-spacing:.2px;
    }
    .logo{
      width:34px;height:34px;border-radius:10px;
      background:
        conic-gradient(from 180deg, #7c5cff, #23d18b, #ffcc66, #ff5c7a, #7c5cff);
      box-shadow: 0 10px 30px rgba(124,92,255,.25);
      border:1px solid rgba(255,255,255,.18);
    }

    .hdr .btns{display:flex; gap:10px; align-items:center; flex-wrap:wrap; justify-content:flex-end}
    .btn{
      appearance:none;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.07);
      color:var(--text);
      padding:10px 12px;
      border-radius: 14px;
      font-weight:650;
      font-size:14px;
      line-height:1;
      cursor:pointer;
      transition: transform .08s ease, background .2s ease, border-color .2s ease;
      user-select:none;
      -webkit-tap-highlight-color: transparent;
    }
    .btn:hover{background: rgba(255,255,255,.10)}
    .btn:active{transform: translateY(1px) scale(.99)}
    .btn.primary{
      background: linear-gradient(180deg, rgba(124,92,255,.95), rgba(124,92,255,.70));
      border-color: rgba(124,92,255,.55);
      box-shadow: 0 14px 30px rgba(124,92,255,.25);
    }
    .btn.ghost{
      background: rgba(0,0,0,.12);
      border-color: rgba(255,255,255,.12);
    }

    .card{
      background: rgba(255,255,255,.05);
      border:1px solid var(--stroke);
      border-radius: 16px;
      padding:12px;
    }
    .cardTitle{
      display:flex; align-items:center; justify-content:space-between;
      font-weight:750;
      font-size:14px;
      color: rgba(255,255,255,.88);
      margin-bottom:10px;
      letter-spacing:.2px;
    }
    .grid2{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .stat{
      padding:10px 10px;
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      display:flex;
      flex-direction:column;
      gap:4px;
      min-height: 62px;
    }
    .stat .k{font-size:12px; color:var(--muted)}
    .stat .v{font-size:20px; font-weight:800; letter-spacing:.2px}

    .miniRow{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap:10px;
    }

    .mini{
      background: rgba(0,0,0,.16);
      border:1px solid rgba(255,255,255,.10);
      border-radius: 14px;
      padding:10px;
      display:flex; flex-direction:column; gap:8px;
    }
    .mini canvas{
      width:100%;
      height:100px;
      max-height:100px;
      background: rgba(0,0,0,.10);
      border-radius: 12px;
      border:1px solid rgba(255,255,255,.08);
    }
    .mini .label{font-size:12px; color:var(--muted); display:flex; justify-content:space-between; align-items:center}
    .pill{
      padding:4px 8px;
      border-radius: 999px;
      background: rgba(255,255,255,.08);
      border:1px solid rgba(255,255,255,.10);
      font-size:12px;
      color: rgba(255,255,255,.80);
    }

    .hint{
      font-size:12px;
      color: rgba(255,255,255,.70);
      line-height:1.35;
    }
    kbd{
      font: 12px ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      padding:2px 7px;
      border-radius: 8px;
      border:1px solid rgba(255,255,255,.14);
      background: rgba(0,0,0,.16);
      color: rgba(255,255,255,.86);
      display:inline-block;
      margin: 2px 2px;
      white-space:nowrap;
    }

    .controls{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap:10px;
      align-items:stretch;
    }
    .controls .btn{
      padding:14px 10px;
      font-size:14px;
      border-radius: 16px;
      text-align:center;
      background: rgba(255,255,255,.06);
    }
    .controls .btn.primary{
      background: linear-gradient(180deg, rgba(35,209,139,.95), rgba(35,209,139,.70));
      border-color: rgba(35,209,139,.55);
      box-shadow: 0 14px 30px rgba(35,209,139,.18);
    }
    .controls .btn.wide{grid-column: span 2;}
    .controls .btn.hold{
      background: linear-gradient(180deg, rgba(255,204,102,.95), rgba(255,204,102,.70));
      border-color: rgba(255,204,102,.55);
      color: rgba(0,0,0,.85);
      box-shadow: 0 14px 30px rgba(255,204,102,.16);
    }

    .overlay{
      position:absolute;
      inset:12px;
      border-radius: 12px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      text-align:center;
      gap:10px;
      background: rgba(0,0,0,.55);
      border:1px solid rgba(255,255,255,.14);
      backdrop-filter: blur(10px);
      -webkit-backdrop-filter: blur(10px);
      opacity:0;
      pointer-events:none;
      transition: opacity .2s ease;
      padding:16px;
    }
    .overlay.show{opacity:1; pointer-events:auto;}
    .overlay h2{
      margin:0;
      font-size:22px;
      letter-spacing:.2px;
    }
    .overlay p{
      margin:0;
      color: rgba(255,255,255,.72);
      font-size:13px;
      line-height:1.4;
      max-width: 380px;
    }
    .overlay .row{display:flex; gap:10px; flex-wrap:wrap; justify-content:center; margin-top:6px;}
    .tiny{
      font-size:12px;
      color: rgba(255,255,255,.65);
    }

    .footerNote{
      padding:10px 12px;
      border-top:1px solid var(--stroke);
      color: rgba(255,255,255,.60);
      font-size:12px;
      display:flex;
      justify-content:space-between;
      gap:10px;
      flex-wrap:wrap;
      background: rgba(255,255,255,.02);
    }

    .toggle{
      display:inline-flex;
      align-items:center;
      gap:8px;
      cursor:pointer;
      user-select:none;
    }
    .toggle input{display:none}
    .switch{
      width:44px;height:26px;border-radius:999px;
      background: rgba(255,255,255,.10);
      border:1px solid rgba(255,255,255,.16);
      position:relative;
      transition: background .2s ease, border-color .2s ease;
    }
    .switch::after{
      content:"";
      position:absolute; top:50%; left:3px;
      width:20px;height:20px;border-radius:999px;
      transform: translateY(-50%);
      background: rgba(255,255,255,.88);
      transition: left .2s ease, background .2s ease;
      box-shadow: 0 8px 20px rgba(0,0,0,.35);
    }
    .toggle input:checked + .switch{
      background: rgba(124,92,255,.35);
      border-color: rgba(124,92,255,.55);
    }
    .toggle input:checked + .switch::after{left:21px; background: white;}
  </style>
</head>
<body>
  <div class="app">
    <section class="panel">
      <div class="hdr">
        <div class="brand">
          <div class="logo"></div>
          <div>
            <div style="font-size:16px; line-height:1.1;">Tetris</div>
            <div style="font-size:12px;color:rgba(255,255,255,.65);font-weight:600;">Классика</div>
          </div>
        </div>
        <div class="btns">
          <button id="btnStart" class="btn primary">Старт</button>
          <button id="btnPause" class="btn ghost">Пауза</button>
          <button id="btnRestart" class="btn">Заново</button>
        </div>
      </div>

      <div class="boardWrap">
        <div class="canvasCard">
          <canvas id="game" width="300" height="600" aria-label="Tetris board"></canvas>
          <div id="overlay" class="overlay">
            <h2 id="overlayTitle">Тетрис</h2>
            <p id="overlayText">Нажмите «Старт» или <kbd>Enter</kbd>. Управление: <kbd>←</kbd><kbd>→</kbd>, <kbd>↓</kbd>, <kbd>↑</kbd>/<kbd>X</kbd> (поворот), <kbd>Z</kbd> (обратно), <kbd>Space</kbd> (дроп), <kbd>C</kbd> (холд).</p>
            <div class="row">
              <button id="btnOverlayStart" class="btn primary">Играть</button>
              <button id="btnOverlayRestart" class="btn">Заново</button>
            </div>
            <div class="tiny" id="overlayTiny"></div>
          </div>
        </div>

        <aside class="side">
          <div class="card">
            <div class="cardTitle">
              <span>Статистика</span>
              <span class="pill" id="statusPill">Готов</span>
            </div>
            <div class="grid2">
              <div class="stat"><div class="k">Очки</div><div class="v" id="score">0</div></div>
              <div class="stat"><div class="k">Линии</div><div class="v" id="lines">0</div></div>
              <div class="stat"><div class="k">Уровень</div><div class="v" id="level">1</div></div>
              <div class="stat"><div class="k">Рекорд</div><div class="v" id="best">0</div></div>
            </div>
          </div>

          <div class="card">
            <div class="miniRow">
              <div class="mini">
                <div class="label"><span>Следующая</span><span class="pill">NEXT</span></div>
                <canvas id="next" width="160" height="120"></canvas>
              </div>
              <div class="mini">
                <div class="label"><span>Холд</span><span class="pill">C</span></div>
                <canvas id="hold" width="160" height="120"></canvas>
              </div>
            </div>
            <div style="height:10px"></div>
            <div class="controls" aria-label="Touch controls">
              <button class="btn" id="tLeft">←</button>
              <button class="btn" id="tRotate">⟳</button>
              <button class="btn" id="tRight">→</button>
              <button class="btn hold" id="tHold">Холд</button>
              <button class="btn" id="tDown">↓</button>
              <button class="btn primary wide" id="tDrop">Дроп</button>
            </div>
            <div style="height:10px"></div>
            <div class="hint">
              <div><kbd>←</kbd><kbd>→</kbd> движение • <kbd>↓</kbd> мягкое падение</div>
              <div><kbd>↑</kbd>/<kbd>X</kbd> поворот • <kbd>Z</kbd> обратно</div>
              <div><kbd>Space</kbd> мгновенный дроп • <kbd>C</kbd> холд • <kbd>P</kbd> пауза</div>
            </div>
          </div>

          <div class="card">
            <div class="cardTitle"><span>Настройки</span><span class="pill">SFX</span></div>
            <label class="toggle">
              <input id="sfxToggle" type="checkbox" checked />
              <span class="switch" aria-hidden="true"></span>
              <span style="color:rgba(255,255,255,.75);font-weight:650">Звук</span>
            </label>
            <div style="height:8px"></div>
            <div class="hint">Сохраняет рекорд в браузере. На мобильных используйте кнопки управления ниже.</div>
          </div>
        </aside>
      </div>

      <div class="footerNote">
        <div>© Classic Tetris • Canvas</div>
        <div>Подсказка: удерживайте <kbd>↓</kbd> / кнопку «↓» для ускорения</div>
      </div>
    </section>
  </div>

<script>
(() => {
  // ---------- Utilities ----------
  const $ = (sel) => document.querySelector(sel);
  const clamp = (v, a, b) => Math.max(a, Math.min(b, v));

  // ---------- Audio (tiny synth) ----------
  const SFX = (() => {
    let ctx = null;
    const enabled = () => $("#sfxToggle").checked;

    function ensure(){
      if (!ctx) ctx = new (window.AudioContext || window.webkitAudioContext)();
      if (ctx.state === "suspended") ctx.resume().catch(()=>{});
    }

    function beep({freq=440, dur=0.06, type="sine", gain=0.03, slide=0} = {}){
      if (!enabled()) return;
      ensure();
      const t0 = ctx.currentTime;
      const o = ctx.createOscillator();
      const g = ctx.createGain();
      o.type = type;
      o.frequency.setValueAtTime(freq, t0);
      if (slide) o.frequency.exponentialRampToValueAtTime(freq * slide, t0 + dur);
      g.gain.setValueAtTime(gain, t0);
      g.gain.exponentialRampToValueAtTime(0.0001, t0 + dur);
      o.connect(g).connect(ctx.destination);
      o.start(t0);
      o.stop(t0 + dur + 0.01);
    }

    return {
      move(){ beep({freq: 420, dur: 0.03, type:"triangle", gain:0.015}); },
      rotate(){ beep({freq: 620, dur: 0.04, type:"square", gain:0.012}); },
      soft(){ beep({freq: 220, dur: 0.02, type:"sine", gain:0.010}); },
      lock(){ beep({freq: 160, dur: 0.05, type:"sawtooth", gain:0.020, slide:1.6}); },
      clear(lines){
        const f = [520, 660, 820, 980][clamp(lines-1,0,3)];
        beep({freq: f, dur: 0.09, type:"triangle", gain:0.03});
      },
      drop(){ beep({freq: 260, dur: 0.06, type:"square", gain:0.02, slide:1.9}); },
      hold(){ beep({freq: 360, dur: 0.05, type:"triangle", gain:0.018}); },
      over(){ beep({freq: 110, dur: 0.18, type:"sawtooth", gain:0.03, slide:0.6}); },
      start(){ beep({freq: 740, dur: 0.07, type:"triangle", gain:0.025}); },
      pause(){ beep({freq: 300, dur: 0.06, type:"triangle", gain:0.02}); }
    };
  })();

  // ---------- Tetris core ----------
  const COLS = 10, ROWS = 20;
  const BLOCK = 30; // canvas logical size uses 300x600
  const boardCanvas = $("#game");
  const ctx = boardCanvas.getContext("2d", { alpha: false });
  ctx.imageSmoothingEnabled = false;

  const nextCanvas = $("#next");
  const nextCtx = nextCanvas.getContext("2d", { alpha: true });
  nextCtx.imageSmoothingEnabled = false;

  const holdCanvas = $("#hold");
  const holdCtx = holdCanvas.getContext("2d", { alpha: true });
  holdCtx.imageSmoothingEnabled = false;

  // Colors (modern neon)
  const COLORS = {
    I: "#37d7ff",
    O: "#ffd24a",
    T: "#b07cff",
    S: "#31e07f",
    Z: "#ff557a",
    J: "#5aa0ff",
    L: "#ff9b3d",
    G: "rgba(255,255,255,.12)" // ghost edge
  };

  // 4x4 matrices (spawn rotation state)
  const SHAPES = {
    I: [
      [0,0,0,0],
      [1,1,1,1],
      [0,0,0,0],
      [0,0,0,0],
    ],
    O: [
      [0,1,1,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    T: [
      [0,1,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    S: [
      [0,1,1,0],
      [1,1,0,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    Z: [
      [1,1,0,0],
      [0,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    J: [
      [1,0,0,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
    L: [
      [0,0,1,0],
      [1,1,1,0],
      [0,0,0,0],
      [0,0,0,0],
    ],
  };

  const TYPES = Object.keys(SHAPES);

  // Simple 7-bag randomizer
  function* bagGenerator(){
    while(true){
      const bag = TYPES.slice();
      for (let i = bag.length - 1; i > 0; i--){
        const j = (Math.random() * (i + 1)) | 0;
        [bag[i], bag[j]] = [bag[j], bag[i]];
      }
      for (const t of bag) yield t;
    }
  }
  const bagIt = bagGenerator();

  const state = {
    board: createBoard(),
    running: false,
    paused: false,
    gameOver: false,

    score: 0,
    lines: 0,
    level: 1,
    best: Number(localStorage.getItem("tetris_best") || 0),

    dropInterval: 1000,
    lastTime: 0,
    dropAcc: 0,

    current: null,
    next: spawnPiece(),
    hold: null,
    holdLocked: false,

    softDropping: false
  };

  function createBoard(){
    return Array.from({length: ROWS}, () => Array(COLS).fill(null));
  }

  function cloneMatrix(m){ return m.map(r => r.slice()); }

  function spawnPiece(forcedType){
    const type = forcedType || bagIt.next().value;
    const matrix = cloneMatrix(SHAPES[type]);
    // spawn at top center
    const x = ((COLS / 2) | 0) - 2;
    const y = -1; // allow a bit above the board
    return { type, matrix, x, y };
  }

  function resetGame(){
    state.board = createBoard();
    state.score = 0;
    state.lines = 0;
    state.level = 1;
    state.dropInterval = 1000;
    state.lastTime = 0;
    state.dropAcc = 0;
    state.current = null;
    state.next = spawnPiece();
    state.hold = null;
    state.holdLocked = false;
    state.running = false;
    state.paused = false;
    state.gameOver = false;
    state.softDropping = false;
    updateUI();
    showOverlay(true, "Тетрис", "Нажмите «Старт» или <kbd>Enter</kbd>. Управление: <kbd>←</kbd><kbd>→</kbd>, <kbd>↓</kbd>, <kbd>↑</kbd>/<kbd>X</kbd> (поворот), <kbd>Z</kbd> (обратно), <kbd>Space</kbd> (дроп), <kbd>C</kbd> (холд).");
    draw();
    drawMini(nextCtx, state.next?.type);
    drawMini(holdCtx, state.hold?.type);
  }

  function startGame(){
    if (state.gameOver) resetGame();
    if (!state.running){
      state.running = true;
      state.paused = false;
      state.gameOver = false;
      state.current = spawnPiece(); // from bag
      state.holdLocked = false;
      state.dropAcc = 0;
      state.lastTime = performance.now();
      updateStatus();
      showOverlay(false);
      SFX.start();
      requestAnimationFrame(loop);
    } else if (state.paused){
      togglePause(false);
    }
  }

  function togglePause(force){
    if (!state.running || state.gameOver) return;
    const newPaused = typeof force === "boolean" ? force : !state.paused;
    state.paused = newPaused;
    updateStatus();
    if (state.paused){
      showOverlay(true, "Пауза", "Нажмите <kbd>P</kbd> или «Пауза», чтобы продолжить.");
      SFX.pause();
    } else {
      showOverlay(false);
      state.lastTime = performance.now();
      requestAnimationFrame(loop);
      SFX.start();
    }
  }

  function endGame(){
    state.gameOver = true;
    state.running = true; // still in session
    state.paused = true;
    updateStatus();
    if (state.score > state.best){
      state.best = state.score;
      localStorage.setItem("tetris_best", String(state.best));
      $("#best").textContent = String(state.best);
    }
    showOverlay(true, "Игра окончена", "Фигура не помещается. Нажмите «Заново» или <kbd>Enter</kbd>.");
    $("#overlayTiny").textContent = state.score >= state.best ? "Новый рекорд!" : "";
    SFX.over();
  }

  function updateUI(){
    $("#score").textContent = String(state.score);
    $("#lines").textContent = String(state.lines);
    $("#level").textContent = String(state.level);
    $("#best").textContent = String(state.best);
    updateStatus();
  }

  function updateStatus(){
    const pill = $("#statusPill");
    if (!state.running){
      pill.textContent = "Готов";
      pill.style.borderColor = "rgba(255,255,255,.10)";
      pill.style.background = "rgba(255,255,255,.08)";
      return;
    }
    if (state.gameOver){
      pill.textContent = "Конец";
      pill.style.borderColor = "rgba(255,92,122,.45)";
      pill.style.background = "rgba(255,92,122,.16)";
      return;
    }
    if (state.paused){
      pill.textContent = "Пауза";
      pill.style.borderColor = "rgba(255,204,102,.45)";
      pill.style.background = "rgba(255,204,102,.16)";
      return;
    }
    pill.textContent = "Игра";
    pill.style.borderColor = "rgba(35,209,139,.45)";
    pill.style.background = "rgba(35,209,139,.14)";
  }

  function showOverlay(show, title, htmlText){
    const ov = $("#overlay");
    if (show){
      $("#overlayTitle").textContent = title || "Tetris";
      if (htmlText != null) $("#overlayText").innerHTML = htmlText;
      ov.classList.add("show");
    } else {
      ov.classList.remove("show");
      $("#overlayTiny").textContent = "";
    }
  }

  function collide(board, piece){
    const {matrix, x: px, y: py} = piece;
    for (let y = 0; y < 4; y++){
      for (let x = 0; x < 4; x++){
        if (!matrix[y][x]) continue;
        const bx = px + x;
        const by = py + y;
        if (bx < 0 || bx >= COLS) return true;
        if (by >= ROWS) return true;
        if (by >= 0 && board[by][bx]) return true;
      }
    }
    return false;
  }

  function merge(board, piece){
    const {matrix, x: px, y: py, type} = piece;
    for (let y = 0; y < 4; y++){
      for (let x = 0; x < 4; x++){
        if (!matrix[y][x]) continue;
        const bx = px + x;
        const by = py + y;
        if (by >= 0 && by < ROWS && bx >= 0 && bx < COLS){
          board[by][bx] = type;
        }
      }
    }
  }

  function clearLines(){
    let cleared = 0;
    outer: for (let y = ROWS - 1; y >= 0; y--){
      for (let x = 0; x < COLS; x++){
        if (!state.board[y][x]) continue outer;
      }
      state.board.splice(y, 1);
      state.board.unshift(Array(COLS).fill(null));
      cleared++;
      y++;
    }
    if (cleared > 0){
      // Classic scoring: 40,100,300,1200 * level
      const base = [0, 40, 100, 300, 1200][cleared];
      state.score += base * state.level;
      state.lines += cleared;

      const newLevel = 1 + Math.floor(state.lines / 10);
      if (newLevel !== state.level){
        state.level = newLevel;
        // speed curve
        state.dropInterval = Math.max(90, 1000 * Math.pow(0.86, state.level - 1));
      }
      SFX.clear(cleared);
      updateUI();
    }
    return cleared;
  }

  function rotateMatrix(mat, dir){
    // mat 4x4
    const res = Array.from({length:4}, ()=>Array(4).fill(0));
    for (let y=0;y<4;y++){
      for (let x=0;x<4;x++){
        if (dir > 0) res[y][x] = mat[3 - x][y];       // CW
        else res[y][x] = mat[x][3 - y];              // CCW
      }
    }
    return res;
  }

  function tryRotate(dir){
    if (!state.current || state.paused || state.gameOver) return;
    const piece = state.current;
    const rotated = rotateMatrix(piece.matrix, dir);

    // basic wall-kick offsets (works well enough for classic feel)
    const kicks = [0, -1, 1, -2, 2];
    for (const k of kicks){
      const test = { ...piece, matrix: rotated, x: piece.x + k };
      if (!collide(state.board, test)){
        piece.matrix = rotated;
        piece.x += k;
        SFX.rotate();
        return;
      }
    }
  }

  function move(dx){
    if (!state.current || state.paused || state.gameOver) return;
    const test = { ...state.current, x: state.current.x + dx };
    if (!collide(state.board, test)){
      state.current.x += dx;
      SFX.move();
    }
  }

  function softDropOnce(){
    if (!state.current || state.paused || state.gameOver) return false;
    const test = { ...state.current, y: state.current.y + 1 };
    if (!collide(state.board, test)){
      state.current.y++;
      state.score += 1; // soft drop points
      updateUI();
      SFX.soft();
      return true;
    }
    // lock
    lockPiece();
    return false;
  }

  function hardDrop(){
    if (!state.current || state.paused || state.gameOver) return;
    let dist = 0;
    while(true){
      const test = { ...state.current, y: state.current.y + 1 };
      if (collide(state.board, test)) break;
      state.current.y++;
      dist++;
    }
    if (dist > 0){
      state.score += dist * 2;
      updateUI();
    }
    SFX.drop();
    lockPiece();
  }

  function lockPiece(){
    merge(state.board, state.current);
    SFX.lock();
    state.holdLocked = false;
    clearLines();

    // spawn next
    state.current = state.next;
    state.current.x = ((COLS / 2) | 0) - 2;
    state.current.y = -1;
    state.next = spawnPiece();
    drawMini(nextCtx, state.next?.type);

    // If immediately collides -> game over
    if (collide(state.board, state.current)){
      endGame();
    }
  }

  function holdPiece(){
    if (!state.current || state.paused || state.gameOver) return;
    if (state.holdLocked) return;
    state.holdLocked = true;

    const curType = state.current.type;
    if (!state.hold){
      state.hold = { type: curType };
      state.current = state.next;
      state.current.x = ((COLS / 2) | 0) - 2;
      state.current.y = -1;
      state.next = spawnPiece();
      drawMini(nextCtx, state.next?.type);
    } else {
      const swap = state.hold.type;
      state.hold.type = curType;
      state.current = spawnPiece(swap);
    }
    drawMini(holdCtx, state.hold?.type);
    SFX.hold();

    if (collide(state.board, state.current)){
      endGame();
    }
  }

  function getGhostY(board, piece){
    let y = piece.y;
    while(true){
      const test = { ...piece, y: y + 1 };
      if (collide(board, test)) return y;
      y++;
    }
  }

  // ---------- Rendering ----------
  function drawCell(px, py, color, alpha=1){
    const x = px * BLOCK, y = py * BLOCK;
    // base
    ctx.globalAlpha = alpha;
    ctx.fillStyle = color;
    ctx.fillRect(x, y, BLOCK, BLOCK);

    // glossy highlight
    ctx.globalAlpha = alpha * 0.22;
    ctx.fillStyle = "#fff";
    ctx.fillRect(x + 2, y + 2, BLOCK - 4, Math.max(6, BLOCK * 0.30));

    // grid stroke
    ctx.globalAlpha = alpha * 0.45;
    ctx.strokeStyle = "rgba(255,255,255,.14)";
    ctx.lineWidth = 1;
    ctx.strokeRect(x + 0.5, y + 0.5, BLOCK - 1, BLOCK - 1);

    ctx.globalAlpha = 1;
  }

  function drawBoard(){
    // background
    ctx.fillStyle = "#0a0f18";
    ctx.fillRect(0,0, boardCanvas.width, boardCanvas.height);

    // subtle grid
    ctx.save();
    ctx.globalAlpha = 0.10;
    ctx.strokeStyle = "rgba(255,255,255,.20)";
    ctx.lineWidth = 1;
    for (let x=0;x<=COLS;x++){
      ctx.beginPath();
      ctx.moveTo(x*BLOCK + 0.5, 0);
      ctx.lineTo(x*BLOCK + 0.5, ROWS*BLOCK);
      ctx.stroke();
    }
    for (let y=0;y<=ROWS;y++){
      ctx.beginPath();
      ctx.moveTo(0, y*BLOCK + 0.5);
      ctx.lineTo(COLS*BLOCK, y*BLOCK + 0.5);
      ctx.stroke();
    }
    ctx.restore();

    // placed blocks
    for (let y=0;y<ROWS;y++){
      for (let x=0;x<COLS;x++){
        const t = state.board[y][x];
        if (!t) continue;
        drawCell(x, y, COLORS[t], 1);
      }
    }
  }

  function drawPiece(piece, opts = {}){
    const {alpha=1, outline=false, colorOverride=null} = opts;
    const {matrix, x: px, y: py, type} = piece;
    const color = colorOverride || COLORS[type];
    for (let y=0;y<4;y++){
      for (let x=0;x<4;x++){
        if (!matrix[y][x]) continue;
        const bx = px + x;
        const by = py + y;
        if (by < 0) continue;
        if (outline){
          const X = bx*BLOCK, Y = by*BLOCK;
          ctx.save();
          ctx.globalAlpha = alpha;
          ctx.strokeStyle = color;
          ctx.lineWidth = 2;
          ctx.strokeRect(X + 2, Y + 2, BLOCK - 4, BLOCK - 4);
          ctx.restore();
        } else {
          drawCell(bx, by, color, alpha);
        }
      }
    }
  }

  function drawMini(mctx, type){
    mctx.clearRect(0,0, mctx.canvas.width, mctx.canvas.height);
    // soft bg
    mctx.save();
    mctx.fillStyle = "rgba(0,0,0,.18)";
    mctx.fillRect(0,0, mctx.canvas.width, mctx.canvas.height);
    mctx.restore();

    if (!type) return;
    const mat = SHAPES[type];
    const size = 18; // mini block size
    const w = 4 * size, h = 4 * size;
    const ox = (mctx.canvas.width - w) / 2;
    const oy = (mctx.canvas.height - h) / 2 + 2;

    for (let y=0;y<4;y++){
      for (let x=0;x<4;x++){
        if (!mat[y][x]) continue;
        const X = ox + x*size;
        const Y = oy + y*size;
        mctx.save();
        mctx.fillStyle = COLORS[type];
        mctx.globalAlpha = 0.95;
        mctx.fillRect(X, Y, size, size);
        mctx.globalAlpha = 0.20;
        mctx.fillStyle = "#fff";
        mctx.fillRect(X+1, Y+1, size-2, Math.max(5, size*0.33));
        mctx.globalAlpha = 0.45;
        mctx.strokeStyle = "rgba(255,255,255,.16)";
        mctx.strokeRect(X+0.5, Y+0.5, size-1, size-1);
        mctx.restore();
      }
    }
  }

  function draw(){
    drawBoard();
    if (state.current && !state.gameOver){
      // ghost
      const gy = getGhostY(state.board, state.current);
      drawPiece({ ...state.current, y: gy }, { outline: true, alpha: 0.35, colorOverride: "rgba(255,255,255,.65)" });
      // current
      drawPiece(state.current, { alpha: 1 });
    }
  }

  // ---------- Game loop ----------
  function loop(now){
    if (!state.running || state.paused) return;

    const dt = now - state.lastTime;
    state.lastTime = now;
    state.dropAcc += dt;

    const interval = state.softDropping ? Math.min(55, state.dropInterval * 0.08) : state.dropInterval;

    while (state.dropAcc >= interval){
      state.dropAcc -= interval;
      if (!softDropOnce()){
        // locked; break to avoid multi-lock in same frame
        break;
      }
    }

    draw();
    requestAnimationFrame(loop);
  }

  // ---------- Input ----------
  const keyState = new Set();

  function onKeyDown(e){
    const k = e.key;
    if (["ArrowLeft","ArrowRight","ArrowDown","ArrowUp"," ","Spacebar"].includes(k)) e.preventDefault();

    if (k === "Enter"){
      if (!state.running || state.gameOver) startGame();
      else if (state.paused) togglePause(false);
      return;
    }
    if (k === "p" || k === "P"){
      togglePause();
      return;
    }

    if (!state.running) return;
    if (state.gameOver) return;
    if (state.paused) return;

    if (keyState.has(k)) return; // avoid repeats for rotation/hold/drop
    keyState.add(k);

    switch(k){
      case "ArrowLeft": move(-1); break;
      case "ArrowRight": move(1); break;
      case "ArrowDown":
        state.softDropping = true;
        break;
      case "ArrowUp":
      case "x":
      case "X":
        tryRotate(1);
        break;
      case "z":
      case "Z":
        tryRotate(-1);
        break;
      case "c":
      case "C":
        holdPiece();
        break;
      case " ":
      case "Spacebar":
        hardDrop();
        break;
    }
    draw();
  }

  function onKeyUp(e){
    const k = e.key;
    keyState.delete(k);
    if (k === "ArrowDown") state.softDropping = false;
  }

  window.addEventListener("keydown", onKeyDown, {passive:false});
  window.addEventListener("keyup", onKeyUp, {passive:true});

  // ---------- Touch controls (press-and-hold) ----------
  function bindHoldButton(el, onPress, onRelease, {repeat=false, interval=70, delay=160} = {}){
    let t = null, r = null, active = false;
    const down = (ev) => {
      ev.preventDefault();
      if (!state.running) startGame();
      if (state.paused || state.gameOver) return;
      if (active) return;
      active = true;
      onPress?.();
      if (repeat){
        r = setTimeout(() => {
          if (!active) return;
          t = setInterval(() => onPress?.(), interval);
        }, delay);
      }
    };
    const up = (ev) => {
      ev.preventDefault();
      if (!active) return;
      active = false;
      onRelease?.();
      if (r){ clearTimeout(r); r=null; }
      if (t){ clearInterval(t); t=null; }
    };

    el.addEventListener("pointerdown", down, {passive:false});
    window.addEventListener("pointerup", up, {passive:false});
    window.addEventListener("pointercancel", up, {passive:false});
    window.addEventListener("blur", up, {passive:true});
  }

  bindHoldButton($("#tLeft"), () => move(-1), null, {repeat:true, interval:55, delay:140});
  bindHoldButton($("#tRight"), () => move(1), null, {repeat:true, interval:55, delay:140});
  bindHoldButton($("#tDown"), () => { state.softDropping = true; }, () => { state.softDropping = false; }, {repeat:false});
  bindHoldButton($("#tRotate"), () => tryRotate(1), null, {repeat:false});
  bindHoldButton($("#tDrop"), () => hardDrop(), null, {repeat:false});
  bindHoldButton($("#tHold"), () => holdPiece(), null, {repeat:false});

  // ---------- Buttons ----------
  $("#btnStart").addEventListener("click", () => startGame());
  $("#btnPause").addEventListener("click", () => togglePause());
  $("#btnRestart").addEventListener("click", () => { resetGame(); startGame(); });

  $("#btnOverlayStart").addEventListener("click", () => startGame());
  $("#btnOverlayRestart").addEventListener("click", () => { resetGame(); startGame(); });

  // Resume audio context on first interaction (mobile)
  const resumeAudio = () => {
    document.removeEventListener("pointerdown", resumeAudio);
    document.removeEventListener("keydown", resumeAudio);
    // SFX ensures context when needed
  };
  document.addEventListener("pointerdown", resumeAudio, {passive:true});
  document.addEventListener("keydown", resumeAudio, {passive:true});

  // ---------- Init ----------
  $("#best").textContent = String(state.best);
  drawMini(nextCtx, state.next?.type);
  drawMini(holdCtx, state.hold?.type);
  resetGame();

  // initial overlay
  showOverlay(true, "Тетрис", "Нажмите «Старт» или <kbd>Enter</kbd>. Управление: <kbd>←</kbd><kbd>→</kbd>, <kbd>↓</kbd>, <kbd>↑</kbd>/<kbd>X</kbd> (поворот), <kbd>Z</kbd> (обратно), <kbd>Space</kbd> (дроп), <kbd>C</kbd> (холд).");
})();
</script>
</body>
</html>